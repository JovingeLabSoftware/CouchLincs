<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lincs.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="LINCS.html">LINCS</a><ul class='methods'><li data-type='method'><a href="LINCS.html#_getMulti">_getMulti</a></li><li data-type='method'><a href="LINCS.html#_getMultiView">_getMultiView</a></li><li data-type='method'><a href="LINCS.html#_goQQ">_goQQ</a></li><li data-type='method'><a href="LINCS.html#get">get</a></li><li data-type='method'><a href="LINCS.html#getByPert">getByPert</a></li><li data-type='method'><a href="LINCS.html#getExpression">getExpression</a></li><li data-type='method'><a href="LINCS.html#getGoldByCell">getGoldByCell</a></li><li data-type='method'><a href="LINCS.html#getNIDRange">getNIDRange</a></li><li data-type='method'><a href="LINCS.html#getSummaries">getSummaries</a></li><li data-type='method'><a href="LINCS.html#getVehicle">getVehicle</a></li><li data-type='method'><a href="LINCS.html#getZSVC">getZSVC</a></li><li data-type='method'><a href="LINCS.html#instSamePlateVehicles">instSamePlateVehicles</a></li><li data-type='method'><a href="LINCS.html#instShSamePlateVehicles">instShSamePlateVehicles</a></li><li data-type='method'><a href="LINCS.html#saveInstance">saveInstance</a></li><li data-type='method'><a href="LINCS.html#savePert">savePert</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lincs.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var Q = require('q');
var config = require('../config');

/**
 * @class LINCS
 * @classdesc
 * Convenience class to facilitate data I/O to LINCS data on our couchbase server
 * @config {string} [ip] IP address of the couchdb server, from config.js
 * @config {string} [bucket] Name of the LINCS data bucket from config.js
 * @config {string} [password] Password, if any, for specified bucket
 * @example
 * lincs = require('lincs');
 */
var LINCS_MAXGET = 20;
var LINCS_THROTTLE = 100;

var LINCS = function () {
	var _couchbase = require('couchbase');
	var _cluster = new _couchbase.Cluster('couchbase://' + config.couchdb.ip);
	var _bucket = _cluster.openBucket(config.couchdb.bucket, config.couchdb.password, function(err, res) {
    if(err) {
      throw new Error("Failed to connect to bucket.  Please confirm connection details in config.json");
    }
    _bucket.connectionTimeout = 5000;
    _bucket.operationTimeout = 5000;
  });
  var n1ql_url = "http://" + config.couchdb.ip + ":8093";
  var _n1ql = _couchbase.N1qlQuery;
  _bucket.enableN1ql([n1ql_url]);


  
  var _view = _couchbase.ViewQuery;

   // no reason to do this now, but preparing for more logic 
   // and enforecement on accessors in the future.
   this.cluster = _cluster;
   this.bucket = _bucket;
   this.view = _view;
   this.n1ql = _n1ql;

   // query queue
   this._qq = [];
   this._throttle = 0;
};

/**
 * Get data for a set of keys (either primary or view).
 * @param {string[]} keys List of keys. 
 * @param {string} view Name of view, null if keys are primary index keys
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 * @example lincs.get("1").then(function(x) { console.log(x) });
 */
LINCS.prototype.get = function(keys, view, cb) {
  var deferred = Q.defer();
  keys = keys.split(",");
  keys = [].concat(keys); // make sure it's an array even if single value
  if(view) {
    this._getMultiView(keys, view)
    .then(function(x) {
      deferred.resolve(x)
    })
  } else { // must be primary index keys
    this._getMulti(keys)
    .then(function(x) {
      deferred.resolve(x)
    })
    .catch(function(err) {
      throw(err);
    });
  }
  deferred.promise.nodeify(cb);
  return deferred.promise;
};

/**
 * Private: Get multiple documents by primary key.  Unlike couchbase getMulti, 
 * this version is throttled.
 * @param {string[]} keys List of keys. 
 */
LINCS.prototype._getMulti = function(keys) {
  var promises = []
  keys = [].concat(keys);
  while(keys.length > 0) {
    var deferred = Q.defer();
    this._qq.push({key: keys.shift(), promise: deferred});
    promises.push(deferred.promise)
    this._goQQ();
  }
  return Q.all(promises);
}

/**
 * Private: Get multiple documents by view key.  Unlike couchbase getMulti, 
 * this version is throttled.
 * @param {string[]} keys List of keys. 
 * @param {string} view Name of view, null if keys are primary index keys
 */
LINCS.prototype._getMultiView = function(keys, view) {
  var promises = []
  while(ids.length>0) {
    var deferred = Q.defer();
    var i = ids.splice(0, LINCS_MAXGET);
    var query = this.view.from('lincs', view)
      .reduce(false)
      .keys(keys);
    this._qq.push({query: query, promise: deferred.promise});
    promises.push(deferred)
    this._goQQ();
  }
  return Q.all(promises);
}


/**
 * Private: Process the Query Queue with throttling.
 */
LINCS.prototype._goQQ = function() {
  var _self = this;
  if(this._qq.length &amp;&amp; this._throttle &lt; LINCS_THROTTLE) {
    var q = this._qq.shift();
    this._throttle++;
    if(q.hasOwnProperty("query")) {
      this.bucket.query(q.query, function(err, results) { 
        if(err) {
          _self._throttle--;
          q.promise.reject(err);
          _self._goQQ();
        } else {
          _self._throttle--;
          q.promise.resolve(results);
          _self._goQQ();
        }
      });          
    } else if(q.hasOwnProperty("key")) { // seems to be an id
      _self.bucket.get(String(q.key), function(err, results) {
        if(err) {
          _self._throttle--;
          if(err.message.match("does not exist on the server")) {
            q.promise.resolve(null)
          } else {
            q.promise.reject(err);            
          }
          _self._goQQ();
        } else {
          _self._throttle--;
          q.promise.resolve(results.value);
          _self._goQQ();
        }
      });
    } else {
      _self._throttle--;
      q.promise.reject(new Error("queued queries must contain either a query object or key"));
      _self._goQQ();
    }
  }
}


/**
 * Get gold instances for given cell line.
 * @param {string} cell Name of the cell line (e.g. 'A549').
 * @param {integer} skip How many records to skip.  Useful for paging/throttling.
 * @param {integer} limit How many records to return. 
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 * @example
 * lincs.getGoldByCell('VCAP').then(function(err, res) { console.log(res[1])})
 */
LINCS.prototype.getGoldByCell = function(cell, skip, limit, cb) {
	var deferred = Q.defer();
  var start = [cell, "", -10000, -10000];
  var end = [cell, "\uefff", 10000, 10000];
  var query = this.view.from('lincs', 'gold_by_cell')
    .reduce(false)
    .skip(skip)
    .limit(limit)
    .range(start, end);

	this.bucket.query(query, function(err, results) { 
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve(results);
  		}
  	});

  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};


/**
 * Get the vehicle for a given instance
 * @param {string} key The key of the desired instance
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 */

LINCS.prototype.getVehicle = function(key, cb) {
	var deferred = Q.defer();
  	this.bucket.get(key, function(err, doc) {
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve({vehicle: doc.value.metadata.pert_vehicle, 
	  		                  pert_time: doc.value.metadata.pert_time,
	  		                  det_plate: doc.value.metadata.det_plate});
  		}
  	});
  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};

/**
 * Get the vehicle instances for a given instance on the same plate
 * @param {string} key The key of the desired instance
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 */

LINCS.prototype.instSamePlateVehicles = function(key, cb) {
	var deferred = Q.defer();
	var _self = this;
	this.getVehicle(key)
	.then(function(v) {
    // var plate = key.replace(/\:.*/, "");
    var query = _self.view.from('lincs', 'vehicle_by_plate')
        .reduce(false).key( [v.det_plate, v.vehicle, v.pert_time]);
    _self.bucket.query(query, function(err, results) { 
      if(err) {
        deferred.reject(err);
      } else {
        var ids = results.map(function(r) {
          return(r.id);
        });
        Q.all(ids.map(function(id) {
          var d = Q.defer();
          _self.bucket.get(id, function(err, results) {
            if(err) {
              d.reject(err);
            } else {
              d.resolve({id: id, value: results.value});
            }
          });
          return(d.promise);
        }))
        .then(deferred.resolve);
      }
    });
	});
	deferred.promise.nodeify(cb);
  return deferred.promise;
};


/**
 * Get the appropriate shRNA controls given plate id, cell line id, and timepoint
 * @param {string} id The id of the re
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 */

LINCS.prototype.instShSamePlateVehicles = function(id, cb) {
	var deferred = Q.defer();
	var _self = this;
	this.bucket.get(id, function(err, x) {
    var instance = {cell: x.value.metadata.cell_id, time: x.value.metadata.pert_time, plate: x.value.metadata.det_plate};
  	var query = _self.view.from('debug', 'sh_plate_controls').reduce(false)
  	            .key([instance.plate, instance.cell, instance.time]);
  	_self.bucket.query(query, function(err, results) {
  	 if(err) {
          deferred.reject(err);
        } else {
          var ids = results.map(function(r) {
            return(r.id);
          });
          Q.all(ids.map(function(id) {
            var d = Q.defer();
            _self.bucket.get(id, function(err, results) {
              if(err) {
                d.reject(err);
              } else {
                d.resolve({id: id, value: results.value});
              }
            });
            return(d.promise);
          }))
          .then(deferred.resolve);
        }
  	});
	})

	deferred.promise.nodeify(cb);
  return deferred.promise;
};




/**
 * Get the Q2NORM data for a given instance (L1000 only)
 * @param {string} key The key of the desired instance
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 */
LINCS.prototype.getExpression = function(key, cb) {
	var deferred = Q.defer();
	this.bucket.get(key, function(err, doc) {
		if(err) {
			deferred.reject(err);
		} else {
  		deferred.resolve({gene_ids: doc.value.gene_ids, metadata: doc.value.metadata, data: doc.value.data});
		}
	});
	deferred.promise.nodeify(cb);
	return deferred.promise;
};


LINCS.prototype.query = function(q, cb) {
  var deferred = Q.defer();
  var query = this.n1ql.fromString(q);
  this.bucket.query(query, function(err, res) {
    if(err) {
      deferred.reject(err);
    } else {
      deferred.resolve(res);
    }
  });
  deferred.promise.nodeify(cb);
  return deferred.promise;
};

/**
 * Get the range of numerical ids.
 * Our documents have informative keys, but they are not amenable to sorting and ranging.
 * To overcome this we have created a view with numerical keys.  These can be sorted 
 * and ranged, but it is IMPORTANT to understand they are MAY NOT BE UNIQUE and ARE NOT CONTIGUOUS.  
 * We did not want to add the overhead of creating numeric UUIDs.  There are may be several docs
 * per key, but that is fine for our purposes of rapid indexing and ranging.
 * This was done because N1QL's OFFSET is very slow--it retrieves all the documents 
 * up to OFFSET and the returns the number requested by LIMIT.  Using the skip option 
 * on a view is much faster, and using key ranges is even faster. 
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 */
LINCS.prototype.getNIDRange = function(cb) {
  var deferred = Q.defer();
  var query = this.view.from('lincs', 'numerical_index')
    .reduce(true)

  this.bucket.query(query, function(err, results) { 
      if(err) {
        deferred.reject(err);
      } else {
        deferred.resolve(results[0].value);
      }
    });

    deferred.promise.nodeify(cb);
    return deferred.promise;
};

/**
 * Retrieve document summaries by offset or key prefix
 * @param {string} key View key (distil_id) to retrieve.  Can provide starting fragment
                   only (expands to regex \\code{key.*}).  Can be null
 * @param {integer} skip Skip (for paging, defaults to 0).
 * @param {integer} limit Number of docs to return (for paging, defaults to 10).
 * @param {function} cb Call back to be called upon completion of async call.  Optional--can use promises instead.
 */
LINCS.prototype.getSummaries = function(key, skip, limit, cb) {
  key = key || "";
  var deferred = Q.defer();
  var query = this.view.from('metadata', 'metadata')
    .reduce(false)
    .range(key, key+"\uefff");
  query = query.skip(skip || 0).limit(limit || 10);    

  this.bucket.query(query, function(err, results) { 
    if(err) {
      deferred.reject(err);
    } else {
      deferred.resolve(results);
    }
  });

  deferred.promise.nodeify(cb);
  return deferred.promise;
};

/**
 * Get instance ids matching specified cell line and perturbagen.
 * Note that the view this function queries has a compound key.  Therefore,
 * if perturbagen (pert) is specified, cell_line must also be specified.
 * Similarly, if dose and time are specified, perturbagen and cell line 
 * must also be specified.
 * @param {string} cell_line ID of cell lines. Can be null.
 * @param {string} pert Name of perturbagen. Can be null.
 * @param {numeric} dose Dose (numeric, unitless).  Can be null.
 * @param {numeric} time Duration of exposure (numeric, unitless). Can be null.
 * @param {boolean} gold Should query be restricted to gold instances. If null,
 *                       defaults to true.
 * @param {function} cb Call back to be called upon completion of async call.  
 *                       Optional--can use promises instead.
 */
LINCS.prototype.getByPert = function(cell_line, 
                                     pert, 
                                     dose, 
                                     time, 
                                     skip, 
                                     limit, 
                                     gold, 
                                     cb) {
  var query;
  var deferred = Q.defer();
  var startkey = [cell_line || "", pert || "", dose || -999, time || -999];
  var endkey = [cell_line || "\uefff", pert || "\uefff", dose || 9999, time || 9999];
  gold = gold || false;
  
  if(gold) {
    query = this.view.from('lincs', 'gold_by_cell')
      .reduce(false).skip(skip || 0).limit(limit || 1000);
  } else {
    query = this.view.from('lincs', 'all_by_cell')
      .reduce(false).skip(skip || 0).limit(limit || 1000);
  }
  query.options.startkey = JSON.stringify(startkey);  // query.range does not work 
                                                      // because it adds quotes
  query.options.endkey = JSON.stringify(endkey);  

  if(!cell_line &amp;&amp; pert) {
    deferred.reject(new Error("Must specify cell line if perturbagen is specified"));
  } else if((dose || time) &amp;&amp; (!pert || !cell_line)) {
    deferred.reject(new Error("Must specify cell line and perturbagen " +
                                "if dose and duration are specified"));
  }
  this.bucket.query(query, function(err, results) { 
      if(err) {
        deferred.reject(err);
      } else {
        deferred.resolve(results);
      }
    });

    deferred.promise.nodeify(cb);
    return deferred.promise;
};


/**
 * Get zscores (vs. vehicle control) matching specified cell line and perturbagen.
 * Note that the view this function queries has a compound key.  Therefore,
 * if perturbagen (pert) is specified, cell_line must also be specified.
 * Similarly, if dose and time are specified, perturbagen and cell line 
 * must also be specified.
 * @param {string} cell_line ID of cell lines. Can be null.
 * @param {string} pert Name of perturbagen. Can be null.
 * @param {numeric} dose Dose (numeric, unitless).  Can be null.
 * @param {numeric} time Duration of exposure (numeric, unitless). Can be null.
 * @param {boolean} gold Should query be restricted to gold instances. If null,
 *                       defaults to true.
 * @param {function} cb Call back to be called upon completion of async call.  
 *                       Optional--can use promises instead.
 */

LINCS.prototype.getZSVC = function(cell_line, 
                                     pert, 
                                     dose, 
                                     time, 
                                     skip, 
                                     limit, 
                                     gold,
                                     cb) {

  var query;
  var deferred = Q.defer();
  var startkey = [cell_line || "", pert || "", dose || -999, time || -999];
  var endkey = [cell_line || "\uefff", pert || "\uefff", dose || 9999, time || 9999];
  gold = gold || true;
  
  if(gold) {
    query = this.view.from('lincs_zscore', 'ZSVC_L1000_gold')
      .reduce(false).skip(skip || 0).limit(limit || 1000);
  } else {
    query = this.view.from('lincs_zscore', 'ZSVC_L1000')
      .reduce(false).skip(skip || 0).limit(limit || 1000);
  }
  
  query.options.startkey = JSON.stringify(startkey);  // query.range does not work 
                                                      // because it adds quotes
  query.options.endkey = JSON.stringify(endkey);  
  
  if(!cell_line &amp;&amp; pert) {
    deferred.reject(new Error("Must specify cell line if perturbagen is specified"));
  } else if((dose || time) &amp;&amp; (!pert || !cell_line)) {
    deferred.reject(new Error("Must specify cell line and perturbagen " +
                                "if dose and duration are specified"));
  }
  this.bucket.query(query, function(err, results) { 
      if(err) {
        deferred.reject(err);
      } else {
        deferred.resolve(results);
      }
    });

    deferred.promise.nodeify(cb);
    return deferred.promise;
};

/**
 * Insert a perturbation score (e.g. zscore) data document into the store.  
 * @param {string} doc Document in JSON including type, metadata, gene_ids, 
 *                 data, cell, dose, duration, type, gold, method.
 * @param {function} cb Call back to be called upon completion of async call.  
 *                       Optional--can use promises instead.
 */
LINCS.prototype.savePert = function(doc, cb){
  var deferred = Q.defer();
  if(!this._checkParams(doc, ['method', 'dose', 'perturbagen', 'duration', 'gene_ids', 'data'])){
    return(deferred.reject(new Error("document did not contain required parameters (saveInstance")));
  } else {
    if(doc.gene_ids.length != doc.data.length) {
      deferred.reject(new Error("Gene IDs length must match zscores length"));
    }
    doc.type = "pert";
    var id = doc.method + "_" + doc.cell + "_" +  doc.perturbagen +  
             "_" + doc.dose +  "_" + doc.duration;
    this.bucket.upsert(id, JSON.stringify(doc), function(err, res) 
    {
      if(err) {
        deferred.reject(err);
      } else {
        deferred.resolve(id);
      }
   });
  }
  deferred.promise.nodeify(cb);
  return deferred.promise;
};

/**
 * Insert an instance doc (e.g. level 2 data from LINCS) into the store.  
 * @param {string} id Desired document id (aka 'key')
 * @param {string} doc Document in JSON including type, metadata, gene_ids, 
 *                 expression.  Type should indicate what type of data 
 *                 this is, e.g. "q2norm"
 * @param {function} cb Call back to be called upon completion of async call.  
 *                       Optional--can use promises instead.
 */
LINCS.prototype.saveInstance = function(id, doc, cb){
  var deferred = Q.defer();
  

   if(!this._checkParams(doc, ['metadata', 'gene_ids', 'data', 'type'])){

    deferred.reject(new Error("document did not contain required parameters (saveInstance"));

  } else {
    
    if(doc.gene_ids.length != doc.data.length) {
          deferred.reject(new Error("Gene IDs length must match zscores length"));
    }
    this.bucket.upsert(String(id), doc, function(err, res) 
    {
      if(err) {
        deferred.reject(err);
      } else {
        deferred.resolve(id);
      }
   });
  }

  deferred.promise.nodeify(cb);
  return deferred.promise;
};


/* private function to verify parameters in object
*/
LINCS.prototype._checkParams = function(obj, vars) {
    var ok = true;
    vars.forEach(function(v) {
        if(typeof(obj[[v]]) == "undefined") {
            ok = false;
        } 
    });
    return(ok);
};


/* zscore view:
function (doc, meta) {
  if(doc.metadata.type == "ZSVC_L1000") {
    emit([doc.metadata.cell_id,
          doc.metadata.pert_id,
          doc.metadata.pert_dose,
          doc.metadata.pert_time],
         {gene_ids: doc.gene_ids,
          zscores: doc.zscores}
    );
  }
}
*/





module.exports = exports = new LINCS();
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated at Wed Dec 16 2015 15:37:40 GMT+0000 (UTC)
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
