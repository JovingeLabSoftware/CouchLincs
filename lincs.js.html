<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lincs.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lincs.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var Q = require('q');
var config = require('../config');

/**
 * Create the class and connect to couchbase.
 * @config {string} [ip] IP address of the couchdb server, from config.js
 * @config {string} [bucket] Name of the LINCS data bucket from config.js
 * @config {string} [password] Password, if any, for specified bucket
 * @constructor
 */
var LINCS = function () {
	var _couchbase = require('couchbase');
	var _cluster = new _couchbase.Cluster('couchbase://' + config.couchdb.ip);
	var _bucket = _cluster.openBucket(config.couchdb.bucket, config.couchdb.password, function(err, res) {
    if(err) {
      throw new Error("Failed to connect to bucket.  Please confirm connection details in config.json");
    }
  });
  var _view = _couchbase.ViewQuery;

   // no reason to do this now, but preparing for more logic 
   // and enforecement on accessors in the future.
   this.cluster = _cluster;
   this.bucket = _bucket;
   this.view = _view;
};

/**
 * Get gold instances for given cell line.
 * @param {cell} name of the cell line (e.g. 'A549').
 * @param {skip} how many records to skip.  Useful for paging/throttling.
 * @param {limit} how many records to return. 
 * @param {cb} Call back.  Optional--can use promises instead.
 * @example
 * lincs.getGoldByCell('VCAP').then(function(err, res) { console.log(res[1])})
 */
LINCS.prototype.getGoldByCell = function(cell, skip, limit, cb) {
	var deferred = Q.defer();
  var start = [cell, "", -10000, -10000];
  var end = [cell, "\uefff", 10000, 10000];
  var query = this.view.from('lincs', 'gold_by_cell')
    .reduce(false)
    .skip(skip)
    .limit(limit)
    .range(start, end);

	this.bucket.query(query, function(err, results) { 
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve(results);
  		}
  	});

  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};

LINCS.prototype.getGoldByPert = function(name, dose, time, cell, skip, limit, cb) {
	var deferred = Q.defer();
    var start = [cell, name, dose, time];
    var end = [cell, name, dose, time];
    var query = this.view.from('lincs', 'gold_by_cell')
    	.reduce(false)
    	.skip(skip)
    	.limit(limit)
    	.range(start, end);

	this.bucket.query(query, function(err, results) { 
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve(results);
  		}
  	});

  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};

LINCS.prototype.getAllByPert = function(name, dose, time, cell, skip, limit, cb) {
	var deferred = Q.defer();
    var start = [cell, name, dose, time];
    var end = [cell, name, dose, time];
    var query = this.view.from('lincs', 'all_by_cell')
    	.reduce(false)
    	.skip(skip)
    	.limit(limit)
    	.range(start, end);

	this.bucket.query(query, function(err, results) { 
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve(results);
  		}
  	});

  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};

LINCS.prototype.getVehicle = function(key, cb) {
	var deferred = Q.defer();
  	this.bucket.get(key, function(err, doc) {
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve(doc.value.metadata.pert_vehicle);
  		}
  	});
  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};

LINCS.prototype.getExpression = function(key, cb) {
	var deferred = Q.defer();
  	this.bucket.get(key, function(err, doc) {
  		if(err) {
  			deferred.reject(err);
  		} else {
	  		deferred.resolve(doc.value.norm_exp);
  		}
  	});
  	deferred.promise.nodeify(cb);
  	return deferred.promise;
};

module.exports = exports = new LINCS();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="LINCS.html">LINCS</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Mon Nov 16 2015 17:57:46 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
